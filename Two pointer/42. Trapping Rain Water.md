## LeetCode link(Medium)
https://leetcode.com/problems/trapping-rain-water/

## Keyword
Two pointer, Stack

## Problem description
```
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```
## 1/29/2020 Solution using stack

```java
class Solution {
    public int trap(int[] height) {
        int water = 0;
        Stack<Integer> stack = new Stack<>();
        //traverse through the array using stack
        int current = 0;
        while(current < height.length){
            while(!stack.empty() && height[stack.peek()] < height[current]){
                int floor = stack.pop();
                if(stack.empty()) break; //left wall of current water rectangle doesn't exist
                int water_height = Math.min(height[stack.peek()], height[current]) - height[floor];
                int water_width = current - stack.peek() - 1;
                water += water_height * water_width; // add water
            }
            stack.add(current);
            current++;
        }
        return water;
    }
}
```

## Complexity Analyze
One pass\
Time complexity: O(n) Single iteration of O(n) in which each bar can be touched at most twice(due to insertion and deletion from stack) and insertion and deletion from stack takes O(1) time.\
Space complexity: O(n) Stack can take upto O(n) space in case of stairs-like or flat structure.

## Notes
We can simply the problem by trying to calculate each water rectangle and add them all together. Stack is very
helpful in this case

## Key points
Corner cases: when values repeat in the array\
API: Stack.empty(), Stack.pop(), Stack.peek()

## Two pointers

```JAVA
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        //two pointers
        int p1 = 0, p2 = height.length - 1;
        //max height so far for both sides
        int max1 = 0, max2 = 0;
        while(p1 < p2){
            //move the shorter line
            if(height[p1] < height[p2]){
                //update higher line if applicable
                if(height[p1] < max1){
                    ans += (max1 - height[p1]);
                }
                else{
                    max1 = height[p1];
                }
                p1++;
            }
            else{
                //update higher line if applicable
                if(height[p2] < max2){
                    ans += (max2 - height[p2]);
                }
                else{
                    max2 = height[p2];
                }
                p2--;
            }
        }
        return ans;
    }
}
```

## Complexity Analyze
one pass\
Time complexity: O(n) Single iteration of O(n)\
Space complexity: O(1) Only constant space required for left, right, left_max and right_max

## Notes
Instead of computing the left and right parts seperately, we may think of some way to do it in one iteration.

## Key points
Corner cases: \
API: