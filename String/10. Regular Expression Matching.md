## LeetCode link(Hard)
https://leetcode.com/problems/trapping-rain-water/

## Keyword
String Recursion DP

## Problem description
```
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```
## 1/30/2020 Solution Recursion

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //base case
        if(p.isEmpty()) return s.isEmpty();
        //check if first charactor match
        boolean first_match = (!s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));
        //recursion case
        if(p.length() >=2  && p.charAt(1) == '*'){ //when the 2nd char is *
            //two possible cases: when the * repeats preceding char 0 times or >= 1 times
            return isMatch(s, p.substring(2)) || (first_match && isMatch(s.substring(1), p));
        }
        else{ //when the first charactor matches and the rest needs to be judged again
            return first_match && isMatch(s.substring(1), p.substring(1));
        }
    }
}
```

## Complexity Analyze
\
Time complexity: \
Space complexity: 

## Notes
Since we have to check many different suffixes of the text and see if they match the rest of the pattern, it's straightforward to use recursion.
Note that there are only 2 possible cases when the 2nd charactor of the pattern is *

## Key points
Corner cases: When the second charactor of the pattern is *\
API: String.isEmpty(), String.charAt(), String.length(), String.substring()

## Community: Backtracking

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, "", 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, String cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur);
            return;
        }

        if (open < max)
            backtrack(ans, cur+"(", open+1, close, max);
        if (close < open)
            backtrack(ans, cur+")", open, close+1, max);
    }
}
```

## Complexity Analyze
Same as above\
Time complexity: O(4^n / n^(1/2))\
Space complexity: O(4^n / n^(1/2))

## Notes
Instead of adding '(' or ')' every time as in Approach 1, let's only add them when we know it will remain a valid sequence. We can do this by keeping track of the number of opening and closing brackets we have placed so far.\
We can start an opening bracket if we still have one (of n) left to place. And we can start a closing bracket if it would not exceed the number of opening brackets.

## Key points
Corner cases: \
API: