## LeetCode link(Medium)
https://leetcode.com/problems/as-far-from-land-as-possible/

## Keyword
Graph, BFS

## Problem description
```
Given an N x N grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized and return the distance.

The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.

If no land or water exists in the grid, return -1.

 

Example 1:



Input: [[1,0,1],[0,0,0],[1,0,1]]
Output: 2
Explanation: 
The cell (1, 1) is as far as possible from all the land with distance 2.
Example 2:



Input: [[1,0,0],[0,0,0],[0,0,0]]
Output: 4
Explanation: 
The cell (2, 2) is as far as possible from all the land with distance 4.
 

Note:

1 <= grid.length == grid[0].length <= 100
grid[i][j] is 0 or 1
```
## 3/5/2020 DFS with recursion

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        //counter to keep track of the biggest island
        int maxLand = 0;
        //iterate through the entire grid
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){
                    maxLand = Math.max(maxLand, dfs(grid, i, j));
                }
            }
        }
        return maxLand;
    }
    public int dfs(int[][] grid, int row, int col){
        //invalid coordiate or water
        if(row < 0 || col < 0 || row > grid.length - 1 || col > grid[0].length - 1 || grid[row][col] == 0){
            return 0;
        }
        //mark current land
        grid[row][col] = 0;
        //recursively check for connected lands and return total land size
        return 1 + dfs(grid, row - 1, col) + dfs(grid, row + 1, col) + dfs(grid, row, col - 1) + dfs(grid, row, col + 1);
    }
}
```

## Complexity Analyze
nest loop + DFS\
Time complexity: O(m * n)\
Space complexity: O(m * n)

## Notes
We treat any box with 1 as a node of a gragh, then use DFS to traverse all connected nodes using DFS. We can change the int to 0 to easily mark a node as visited. Then we return land found in each DFS and update a total count of max land.

## Key points
Corner cases: \
API:

## 3/5/2020 BFS iteration

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        //counter to keep track of the biggest island
        int maxLand = 0;
        //iterate through the entire grid
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j++){
                if(grid[i][j] == 1){
                    //update max land size every time an island is encountered
                    maxLand = Math.max(maxLand, bfs(grid, i, j));
                }
            }
        }
        return maxLand;
    }
    public int bfs(int[][] grid, int row, int col){
        //use queue to store nodes to be visited
        Queue<int[]> q = new LinkedList<>();
        int land = 0;
        //put the first node in
        q.add(new int[]{row, col});
        //mark visited node
        grid[row][col] = 0;
        land++;
        //breadth first search
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int r = cur[0], c = cur[1];
            //push connected lands into the queue to check later
            if(r > 0 && grid[r - 1][c] == 1) {
                q.add(new int[]{r - 1, c});
                grid[r - 1][c] = 0;
                land++;
            }
            if(c > 0 && grid[r][c - 1] == 1) {
                q.add(new int[]{r, c - 1});
                grid[r][c - 1] = 0;
                land++;
            }
            if(r < grid.length - 1 && grid[r + 1][c] == 1) {
                q.add(new int[]{r + 1, c});
                grid[r + 1][c] = 0;
                land++;
            }
            if(c < grid[0].length - 1 && grid[r][c + 1] == 1) {
                q.add(new int[]{r, c + 1});
                grid[r][c + 1] = 0;
                land++;
            }
        }
        return land;
    }
}
```

## Complexity Analyze
nest loop + BFS\
Time complexity: O(n * m)\
Space complexity: O(min(n, m)) In the worst case, the size of the queue will grow up to min(n, m)

## Notes
Same idea as the last solution, we use BFS for this solution. Note that in the BFS algorithm, we need to mark the land as visited before we put it in the queue to avoid overlapping problem.

## Key points
Corner cases:\
API: Queue.poll(), Queue.add(), Queue.isEmpty()