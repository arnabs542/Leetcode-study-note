## LeetCode link(Hard)
https://leetcode.com/problems/alien-dictionary/

## Keyword
Graph, Topological sort

## Problem description
```
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

Example 1:

Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"
Example 2:

Input:
[
  "z",
  "x"
]

Output: "zx"
Example 3:

Input:
[
  "z",
  "x",
  "z"
] 

Output: "" 

Explanation: The order is invalid, so return "".
Note:

You may assume all letters are in lowercase.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.
```


## 5/29/2020 Topological sort

```java
class Solution {
    public String alienOrder(String[] words) {
        //extract edges and build the graph
        Map<Character, Node> graph = new HashMap<>();
        boolean isFound = false; //only the first different character will trigger the comparison
        for (int i = 0; i < words.length; ++i) {
            //add every character into the graph
            isFound = false;
            for (int j = 0; j < words[i].length(); ++j) {
                graph.computeIfAbsent(words[i].charAt(j), x -> new Node());
                if (!isFound && i > 0 && j < words[i - 1].length() && words[i].charAt(j) != words[i - 1].charAt(j)) {
                    graph.get(words[i - 1].charAt(j)).list.add(words[i].charAt(j));
                    graph.get(words[i].charAt(j)).inDegree++;
                    isFound = true;
                }
            }
            //if the previous string has all same character but longer, the order is impossible
            if (!isFound && i > 0 && words[i - 1].length() > words[i].length()) {
                return "";
            }
        }
        //topology sort the graph
        Queue<Character> q = new LinkedList<>();
        for (char c : graph.keySet()) {
            if (graph.get(c).inDegree == 0) {
                q.add(c);
            }
        }
        StringBuilder sb = new StringBuilder();
        while (!q.isEmpty()) {
            char curr = q.poll();
            sb.append(curr);
            //all neighbors of curr node will lose 1 in degree
            for (var nei : graph.get(curr).list) {
                if (--graph.get(nei).inDegree == 0) {
                    q.add(nei);
                }
            }
            graph.remove(curr);
        }
        //if the graph cannot be topologically sorted
        if (graph.size() != 0) {
            return "";
        }
        return sb.toString();
    }
}

class Node {
    int inDegree;
    List<Character> list;
    public Node() {
        list = new ArrayList<>();
        inDegree = 0;
    }
}
```

## Complexity Analyze
Topological sort with BFS\
Time complexity: O(C) which is the number letters in the original dictionary\
Space complexity: O(U + min(U^2, N)) = O(1)  wWhere U is at most 26

## Notes
Using each adjacent word pairs, we can generate edges from letter to letter representing the order of two letters. Using these edges in a graph where nodes are letters, we can use topological sort to sort all the letters out. Note a special case where the first word contains second words and is longer. This is impossible so we simply need to return "" here.

## Key points
Corner cases: \
API: 

## 3/31/2020 BFS(using stop as routes)

```C++
// Author: Huahua
// Running time: 89 ms
class Solution {
public:
  int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
    if (S == T) return 0;
    
    unordered_map<int, vector<int>> m;
    for (int i = 0; i < routes.size(); ++i)
      for (const int stop : routes[i])
        m[stop].push_back(i);
    
    vector<int> visited(routes.size(), 0);
    queue<int> q;
    q.push(S);
    int buses = 0;
    
    while (!q.empty()) {
      int size = q.size();      
      ++buses;
      while (size--) {
        int curr = q.front(); q.pop();        
        for (const int bus : m[curr]) {
          if (visited[bus]) continue;          
          visited[bus] = 1;
          for (int stop : routes[bus]) {
            if (stop == T) return buses;            
            q.push(stop);
          }
        }        
      }      
    }
    return -1;
  }
};
```

## Complexity Analyze
BFS\
Time complexity: O(m * n)\
Space complexity: O(m * n + m) 

## Notes
We can also use each stop as a node.

## Key points
Corner cases: \
API: 
