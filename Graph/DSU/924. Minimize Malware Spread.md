## LeetCode link(Hard)
https://leetcode.com/problems/minimize-malware-spread/

## Keyword
Graph, Union Find

## Problem description
```
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

 

Example 1:

Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
Example 2:

Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
Example 3:

Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
 

Note:

1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length
```
## 3/18/2020 Union Find

```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        //use union find to build components
        DSU dsu = new DSU(N);
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                if(i != j && graph[i][j] == 1) dsu.union(i, j);
            }
        }
        //mark components with initial node number
        int[] count = new int[N];
        for(var i : initial){
            count[dsu.find(i)]++;
        }
        //find the biggest component with only 1 node initially infected
        int ans = -1, ansSize = -1;
        for(int node : initial){
            int root = dsu.find(node);
            if(count[root] == 1){ //1 node infected component
                int rootSize = dsu.getSize(root);
                if(rootSize > ansSize){
                    ansSize = rootSize;
                    ans = node;
                }
                else if(rootSize == ansSize && node < ans){
                    ansSize = rootSize;
                    ans = node;
                }
            }
        }
        //if no such component exists, we have to remove which ever inital node with smallest index
        if(ans == -1){
            ans = Integer.MAX_VALUE;
            for(int node : initial){
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }
}
class DSU{
    int[] parent;
    int[] rank;
    int[] size;
    public DSU(int n){
        parent = new int[n];
        size = new int[n];
        for(int i = 0; i < n; i++){
            parent[i] = i;
            size[i] = 1;
        }
        rank = new int[n];
    }
    public int find(int i){
        if(parent[i] != i) parent[i] = find(parent[i]);
        return parent[i];
    }
    public void union(int x, int y){
        int px = find(x), py = find(y);
        if(px == py) return;
        if(rank[px] > rank[py]){
            parent[py] = px;
            size[px] += size[py];
        } else if(rank[px] < rank[py]){
            parent[px] = py;
            size[py] += size[py];
        } else{
            parent[px] = py;
            size[py] += size[px];
            rank[py]++;
        }
    }
    public int getSize(int i){
        return size[find(i)];
    }
}
```

## Complexity Analyze
Time complexity: O(N ^ 2)\
Space complexity: O(N)

## Notes
It's very intuitive to find out components in the graph and their size. Then we can traverse through the component and initial infected notes to find the answer. Note the traverse algorithm when finding the anser, it can find both the biggest component and the smallest index of infected note that the component contains.

## Key points
Corner cases:\
API:

## 3/18/2020 Community DFS

```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. Color each component.
        // colors[node] = the color of this node.

        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, -1);
        int C = 0;

        for (int node = 0; node < N; ++node)
            if (colors[node] == -1)
                dfs(graph, colors, node, C++);

        // 2. Size of each color.
        int[] size = new int[C];
        for (int color: colors)
            size[color]++;

        // 3. Find unique colors.
        int[] colorCount = new int[C];
        for (int node: initial)
            colorCount[colors[node]]++;

        // 4. Answer
        int ans = Integer.MAX_VALUE;
        for (int node: initial) {
            int c = colors[node];
            if (colorCount[c] == 1) {
                if (ans == Integer.MAX_VALUE)
                    ans = node;
                else if (size[c] > size[colors[ans]])
                    ans = node;
                else if (size[c] == size[colors[ans]] && node < ans)
                    ans = node;
            }
        }

        if (ans == Integer.MAX_VALUE)
            for (int node: initial)
                ans = Math.min(ans, node);

        return ans;
    }

    public void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.length; ++nei)
            if (graph[node][nei] == 1 && colors[nei] == -1)
                dfs(graph, colors, nei, color);
    }
}
```

## Complexity Analyze
Time complexity: O(N ^ 2)\
Space complexity: O(N)

## Notes
Just like the union find solutiont, but we use DFS to group components

## Key points
Corner cases:\
API:

## 3/18/2020 Community BFS

```C++
class Solution {
public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int min_affected = INT_MAX;
    int min_node = -1;
    sort(begin(initial), end(initial));
    for (int t : initial) {
      vector<int> bad(graph.size(), 0);
      queue<int> q;
      for (int n : initial)
        if (n != t) {
          bad[n] = 1;
          q.push(n);
        }
      int affected = initial.size() - 1;
      while (!q.empty()) {
        int size = q.size();
        while (size--) {
          int n = q.front(); q.pop();
          for (int i = 0; i < graph[n].size(); ++i) {            
            if (graph[n][i] == 0 || bad[i]) continue;
            ++affected;            
            bad[i] = 1;
            q.push(i);
          }
        }
      }      
      if (affected < min_affected) {
        min_affected = affected;
        min_node = t;
      }
    }    
    return min_node;    
  }
};
```

## Complexity Analyze
Time complexity: O(N ^ 3)\
Space complexity: O(N ^ 2)

## Notes
BFS solution, time complexity is too big

## Key points
Corner cases:\
API: