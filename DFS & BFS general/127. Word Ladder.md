## LeetCode link(Medium)
https://leetcode.com/problems/word-ladder/

## Keyword
DFS, Backtracking

## Problem description
```
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
```

## 4/17/2020 BFS

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        //use array to store visit status
        boolean[] visited = new boolean[wordList.size()];
        //use queue to do bfs
        Queue<String> q = new LinkedList<>();
        //initial status
        q.add(beginWord);
        int step = 1;
        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                //poll a new node
                String cur = q.poll();
                //transformation success!
                if(cur.equals(endWord)) return step;
                //add all possible next step words that are not visited into the queue for the next search
                for(int j = 0; j < wordList.size(); j++){
                    if(!visited[j] && transformable(cur, wordList.get(j))){
                        q.add(wordList.get(j));
                        //mark as visited
                        visited[j] = true;
                    }
                }
            }
            step++;
        }
        //transformation fail
        return 0;
    }
    private boolean transformable(String s1, String s2){
        int count = 0;
        for(int i = 0; i < s1.length() && count < 2; i++){
            if(s1.charAt(i) != s2.charAt(i)){
                ++count;
            }
        }
        return count < 2;
    }
}
```

## Complexity Analyze
BFS\
Time complexity: O(n^2 * l) in the worst case, when the graph is skewered in a line, every node needs to be compared with all that's left and each comparison will cost l(length)\
Space complexity: O(n) to hold visited status and the queue.

## Notes
For every node in the queue, we do a search of all it's connected mutation and put these checkd nodes into the queue. The cycle ends when we find the target or run out of nodes to search.
## Key points
Corner cases: \
API:

