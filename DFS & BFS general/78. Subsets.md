## LeetCode link(Medium)
https://leetcode.com/problems/subsets/

## Keyword
DFS, Combination

## Problem description
```
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```
## 4/13/2020 DFS

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        DFS(nums, ans, new ArrayList<>(), 0);
        return ans;
    }
    private void DFS(int[] nums, List<List<Integer>> ans, List<Integer> list, int index){
        //add the current list to answer
        ans.add(new ArrayList<>(list));
        
        for(int i = index; i < nums.length; i++){
            //backtracking, index needs to move forward to avoid duplicates
            list.add(nums[i]);
            DFS(nums, ans, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```

## Complexity Analyze
DFS\
Time complexity: O(2 ^ n)\
Space complexity: O(2 ^ n)

## Notes
DFS to list all possible combination subsets. Note that during the search, we can keep the index moving forward to prevent duplicated combinations Also, for each next search, the start index needs to be i + 1.

## Key points
Corner cases: \
API: