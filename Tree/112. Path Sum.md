## LeetCode link(Easy)
https://leetcode.com/problems/path-sum/

## Keyword
Tree, DFS

## Problem description
```
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```
## 3/23/2020 DFS

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        //corner case
        if(root == null) return false;
        //if the current node is a leaf
        if(root.left == null && root.right == null) return sum == root.val;
        //recursive case
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

## Complexity Analyze
DFS\
Time complexity: O(n) \
Space complexity: O(n)

## Notes
Use DFS to check there's a path sum recursively. Note that we can return false if current node is null to solve the corner case when the tree is empty and make code more concise when the a parent node only has 1 null child.

## Key points
Corner cases:\
API:

## 3/20/2020 DFS

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int maxLevel;
    int sum;
    public int deepestLeavesSum(TreeNode root) {
        maxLevel = 0;
        sum = 0;
        helper(root, 1);
        return sum;
    }
    private void helper(TreeNode root, int level){
        //base case
        if(root == null) return;
        //update max level
        if(level > maxLevel){
            maxLevel = level;
            sum = 0;
        }
        if(level == maxLevel) sum += root.val;
        //dfs children
        helper(root.left, level + 1);
        helper(root.right, level + 1);
    }
}
```

## Complexity Analyze
DFS\
Time complexity: O(n)\
Space complexity: O(n)

## Notes
We can use DFS instead, and keep a global variable for the max level

## Key points
Corner cases:\
API: