## LeetCode link(Hard)
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/

## Keyword
Tree, String

## Problem description
```
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example: 

You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
```
## 3/24/2020 recursion

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    int count;
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        //use DFS to build the string
        DFSSe(root, sb);
        return sb.toString();
    }
    private void DFSSe(TreeNode root, StringBuilder sb){
        //base case
        if(root == null){
            sb.append("$ ");
            return;
        }
        //add the current node
        sb.append(root.val);
        sb.append(" ");
        DFSSe(root.left, sb);
        DFSSe(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //reset iterator
        count = 0;
        //use DFS to rebuild the tree
        return DFSDe(data);
    }
    private TreeNode DFSDe(String data){
        TreeNode cur = next(data);
        //base case
        if(cur == null) return null;
        //recursively build subtree
        cur.left = DFSDe(data);
        cur.right = DFSDe(data);
        return cur;
    }
    //method to get a node value out
    private TreeNode next(String data){
        StringBuilder cur = new StringBuilder();
        while(data.charAt(count) != ' '){
            cur.append(data.charAt(count));
            count++;
        }
        //skip separator
        count++;
        if(cur.charAt(0) == '$') return null;
        else return new TreeNode(Integer.parseInt(cur.toString()));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## Complexity Analyze
recursion DFS\
Time complexity: O(n)\
Space complexity: O(n)

## Notes
For both serialization and deserialization, we use the recursion to do preorder DFS. String manipulation is also part of this problem. Note that we should use StringBuilder not String concatenation to save time and space.

## Key points
Corner cases: \
API: StringBuilder.append(), String.split(), Integer.parseInt()

## 3/24/2020 BFS

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    int count;
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        //corner case
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        //use queue for BFS
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode cur = q.poll();
            if(cur == null) sb.append("$ ");
            else{
                sb.append(cur.val);
                sb.append(" ");
                q.add(cur.left);
                q.add(cur.right);
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //corner case
        if(data.equals("")) return null;
        //reset iterator
        count = 0;
        TreeNode root = next(data);
        //use queue for BFS
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode cur = q.poll();
            TreeNode left = next(data);
            TreeNode right = next(data);
            cur.left = left;
            cur.right = right;
            if(left != null) q.add(left);
            if(right != null) q.add(right);
        }
        return root;
    }
    //method to get a node value out
    private TreeNode next(String data){
        StringBuilder cur = new StringBuilder();
        while(data.charAt(count) != ' '){
            cur.append(data.charAt(count));
            count++;
        }
        //skip separator
        count++;
        if(cur.charAt(0) == '$') return null;
        else return new TreeNode(Integer.parseInt(cur.toString()));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## Complexity Analyze
BFS\
Time complexity: O(n)\
Space complexity: O(n)

## Notes
For both serialization and deserialization, we use BFS implemented by queue and iteration. String manipulation is also part of this problem. Note that we should use StringBuilder not String concatenation to save time and space.

## Key points
Corner cases: \
API: StringBuilder.append(), String.split(), Integer.parseInt()
