## LeetCode link(Hard)
https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

## Keyword
DP, sliding window

## Problem description
```
In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.

Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.

Example:

Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
 

Note:

nums.length will be between 1 and 20000.
nums[i] will be between 1 and 65535.
k will be between 1 and floor(nums.length / 3).
```

## 6/8/2020 Community left and right
```java
class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        // W is an array of sums of all windows
        int[] W = new int[nums.length - k + 1];
        int currSum = 0;
        for (int i = 0; i < nums.length; i++) {
            currSum += nums[i];
            if (i >= k) {
                currSum -= nums[i - k];
            }
            if (i >= k - 1) {
                W[i - k + 1] = currSum;
            }
        }
        
        //max window sum index so far starting from left
        int[] left = new int[W.length];
        int best = 0;
        for (int i = 0; i < W.length; i++) {
            if (W[i] > W[best]) best = i;
            left[i] = best;
        }
        
        //max window sum index so far starting from right
        int[] right = new int[W.length];
        best = W.length - 1;
        for (int i = W.length - 1; i >= 0; i--) {
            if (W[i] >= W[best]) {
                best = i;
            }
            right[i] = best;
        }
        
        int[] ans = new int[]{-1, -1, -1};
        //slide the middle window
        for (int j = k; j < W.length - k; j++) {
            int i = left[j - k], l = right[j + k];
            //if a better total sum occurs, update the current start index of the best window combination
            if (ans[0] == -1 || W[i] + W[j] + W[l] > W[ans[0]] + W[ans[1]] + W[ans[2]]) {
                ans[0] = i;
                ans[1] = j;
                ans[2] = l;
            }
        }
        return ans;
    }
}
```

## Complexity Analyze
dp left and right\
Time complexity: O(n)\
Space complexity: O(n)

## Notes
Compute and store all window sum first. Use dp to store max window sum start index so far starting from left and right. Then slide the middle window for all possible locations and try to find the maximum total sum and update the starting index of windows at the max sum.

## Key points
Corner cases: \
API:

## 6/8/2020 3 sliding windows
```java
class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        //set 3 sliding windows
        int winIndex1 = 0;
        int[] winIndex2 = new int[] {0, k};
        int[] winIndex3 = new int[] {0, k, 2 * k};
        int winSum1 = 0;
        int winSum2 = 0;
        int winSum3 = 0;
        int winMax1 = 0;
        int winMax2 = 0;
        int winMax3 = 0;
        for (int i = 0; i < k; ++i) {
            winSum1 += nums[i];
        }
        winMax1 = winSum1;
        for (int i = k; i < 2 * k; ++i) {
            winSum2 += nums[i];
        }
        winMax2 = winSum2 + winMax1;
        for (int i = 0;i < k; ++i) {
            winSum3 += nums [i];
        }
        winMax3 = winSum3 + winMax2;
        //slide all three windows together
        for (int i = 3 * k; i < nums.length; ++i) {
            //update current window 1 sum and the max of 1 window so far
            winSum1 += nums[i - 2 * k];
            winSum1 -= nums[i - 3 * k];
            if (winSum1 > winMax1) {
                winIndex1 = i - 3 * k + 1;
                winMax1 = winSum1;
            }
            //update current window 2 sum and the max of 2 windows so far
            winSum2 += nums[i - k];
            winSum2 -= nums[i - 2 * k];
            if (winSum2 + winMax1 > winMax2) {
                winIndex2[0] = winIndex1;
                winIndex2[1] = i - 2 * k + 1;
                winMax2 = winSum2 + winMax1;
            }
            //update current window 3 sum and the max of 3 windows so far
            winSum3 += nums[i];
            winSum3 -= nums[i - k];
            if (winSum3 + winMax2 > winMax3) {
                winIndex3[0] = winIndex2[0];
                winIndex3[1] = winIndex2[1];
                winIndex3[2] = i - k + 1;
                winMax3 = winSum3 + winMax2;
            }
        }
        return winIndex3;
    }
}
```

## Complexity Analyze
3 sliding windows\
Time complexity: O(n)\
Space complexity: O(n)

## Notes
slide three windows together, the total max sum of x windows might be updated by the current x-th window sum + max sum of x - 1 windows. Note we have to update starting index in a staircase manner.

## Key points
Corner cases: \
API: