## LeetCode link(Hard)
https://leetcode.com/problems/interleaving-string/

## Keyword
String, DP

## Problem description
```
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
Example 2:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
```
## 5/1/2020 Recursion

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //base case
        if(p.isEmpty()) return s.isEmpty();
        //check if first charactor match
        boolean first_match = (!s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));
        //recursion case
        if(p.length() >=2  && p.charAt(1) == '*'){ //when the 2nd char is *
            //two possible cases: when the * repeats preceding char 0 times or >= 1 times
            return isMatch(s, p.substring(2)) || (first_match && isMatch(s.substring(1), p));
        }
        else{ //when the first charactor matches and the rest needs to be judged again
            return first_match && isMatch(s.substring(1), p.substring(1));
        }
    }
}
```

## Complexity Analyze
With some effort outside the scope of this article...\
Time complexity: O((T+P)2^(T+P/2))\
Space complexity: O((T+P)2^(T+P/2))

## Notes
Since we have to check many different suffixes of the text and see if they match the rest of the pattern, it's straightforward to use recursion.
Note that there are only 2 possible cases when the 2nd charactor of the pattern is *

## Key points
Corner cases: When the second charactor of the pattern is *\
API: String.isEmpty(), String.charAt(), String.length(), String.substring()

## 5/2/2020 DP Top-Down
```java
 public class Solution {
    public boolean is_Interleave(String s1, int i, String s2, int j, String s3, int k, int[][] memo) {
        if (i == s1.length()) {
            return s2.substring(j).equals(s3.substring(k));
        }
        if (j == s2.length()) {
            return s1.substring(i).equals(s3.substring(k));
        }
        if (memo[i][j] >= 0) {
            return memo[i][j] == 1 ? true : false;
        }
        boolean ans = false;
        if (s3.charAt(k) == s1.charAt(i) && is_Interleave(s1, i + 1, s2, j, s3, k + 1, memo)
                || s3.charAt(k) == s2.charAt(j) && is_Interleave(s1, i, s2, j + 1, s3, k + 1, memo)) {
            ans = true;
        }
        memo[i][j] = ans ? 1 : 0;
        return ans;
    }
    public boolean isInterleave(String s1, String s2, String s3) {
        int memo[][] = new int[s1.length()][s2.length()];
        for (int i = 0; i < s1.length(); i++) {
            for (int j = 0; j < s2.length(); j++) {
                memo[i][j] = -1;
            }
        }
        return is_Interleave(s1, 0, s2, 0, s3, 0, memo);
    }
}
```

## Complexity Analyze
dp top-down\
Time complexity: O(m * n)\
Space complexity: O(m * n)

## Notes
As the problem has an optimal substructure, it is natural to cache intermediate results. We ask the question dp(i, j): does text[i:] and pattern[j:] match? We can describe our answer in terms of answers to questions involving smaller strings.

## Key points
Corner cases: \
API:

## 5/2/2020 DP Buttom-Up
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        //corner case
        if (m + n != s3.length()){
            return false;
        }
        //use dp array to store if the two substring of s1 and s2 can form a substring of s3
        boolean[][] dp = new boolean[m + 1][n + 1];
        //base cases
        //two empty string can form an empty string
        dp[0][0] = true;
        int count = 1;
        //s1 or s2 alone to form se
        while(count <= m && s1.charAt(count - 1) == s3.charAt(count - 1)){
            dp[count][0] = true;
            ++count;
        }
        while(count <= n && s2.charAt(count - 1) == s3.charAt(count - 1)){
            dp[0][count] = true;
            ++count;
        }
        //interate through all cases
        for(int i = 1; i <= m; ++i){
            for(int j = 1; j <= n; ++j){
                if((dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))){
                    dp[i][j] = true;
                }
            }
        }
        return dp[m][n];
    }
}
```

## Complexity Analyze
dp Bottom-Up\
Time complexity: O(m * n)\
Space complexity: O(m * n)

## Notes
We use dp array to store if the two substring of s1 and s2 can form a substring of s3. The result dp[i][j] depends on dp[i - 1][j] and dp[i][j - 1] and the current character.

## Key points
Corner cases: \
API:

## 5/2/2020 DP Buttom-Up
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        //corner case
        if (m + n != s3.length()){
            return false;
        }
        //use dp array to store if the two substring of s1 and s2 can form a substring of s3
        boolean[][] dp = new boolean[m + 1][n + 1];
        //base cases
        //two empty string can form an empty string
        dp[0][0] = true;
        int count = 1;
        //s1 or s2 alone to form se
        while(count <= m && s1.charAt(count - 1) == s3.charAt(count - 1)){
            dp[count][0] = true;
            ++count;
        }
        while(count <= n && s2.charAt(count - 1) == s3.charAt(count - 1)){
            dp[0][count] = true;
            ++count;
        }
        //interate through all cases
        for(int i = 1; i <= m; ++i){
            for(int j = 1; j <= n; ++j){
                if((dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))){
                    dp[i][j] = true;
                }
            }
        }
        return dp[m][n];
    }
}
```

## Complexity Analyze
dp Bottom-Up\
Time complexity: O(m * n)\
Space complexity: O(m * n)

## Notes
We use dp array to store if the two substring of s1 and s2 can form a substring of s3. The result dp[i][j] depends on dp[i - 1][j] and dp[i][j - 1] and the current character.

## Key points
Corner cases: \
API:

## 5/2/2020 DP Buttom-Up 1D
```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        //corner case
        if (m + n != s3.length()){
            return false;
        }
        //use dp array to store if the two substring of s1 and s2 can form a substring of s3
        boolean[] dp = new boolean[n + 1];
        //interate through all cases
        for(int i = 0; i <= m; ++i){
            for(int j = 0; j <= n; ++j){
                //two empty string can form an empty string
                if(i == 0 && j == 0){
                    dp[j] = true;
                }
                //when s1 is empty
                else if(i == 0){
                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
                }
                //when s2 is empty
                else if(j == 0){
                    dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);
                }
                else if((dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))){
                    dp[j] = true;
                }
                else{
                    dp[j] = false;
                }
            }
        }
        return dp[n];
    }
}
```

## Complexity Analyze
dp Bottom-Up\
Time complexity: O(m * n)\
Space complexity: O(n)

## Notes
Same as above but with 1D dp array

## Key points
Corner cases: \
API: