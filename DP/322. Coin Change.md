## LeetCode link(Medium)
https://leetcode.com/problems/coin-change/

## Keyword
DP

## Problem description
```
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Note:
You may assume that you have an infinite number of each kind of coin.
```

## 5/6/2020 DP Bottom-Up

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //use dp array to store the coin number for each amount that's less and equal to amount
        int[] dp = new int[amount + 1];
        //base cases
        Arrays.fill(dp, -1);
        dp[0] = 0;
        //compute number of coins needed for each amount
        for (int i = 1; i <= amount; ++i){
            //for each coin type
            for (var coin : coins){
                //skip negative or impossible cases cases
                if (i < coin || dp[i - coin] == -1){
                    continue;
                }
                dp[i] = dp[i] == -1 ? dp[i - coin] + 1 : Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount];
    }
}
```

## Complexity Analyze
DP Bottom-Up\
Time complexity: O(n * k)\
Space complexity: O(n)

## Notes
Use dp array to store the number of coins you need to make up each amount.

## Key points
Corner cases: \
API: